import ObjectID from 'bson-objectid';
import { fieldAffectsData, fieldIsPresentationalOnly, } from '../../../../fields/config/types';
const buildValidationPromise = async (fieldState, options) => {
    const validatedFieldState = fieldState;
    let validationResult = true;
    if (typeof fieldState.validate === 'function') {
        validationResult = await fieldState.validate(fieldState.value, options);
    }
    if (typeof validationResult === 'string') {
        validatedFieldState.errorMessage = validationResult;
        validatedFieldState.valid = false;
    }
    else {
        validatedFieldState.valid = true;
    }
};
const buildStateFromSchema = async (args) => {
    const { fieldSchema, data: fullData = {}, user, id, operation, } = args;
    if (fieldSchema) {
        const validationPromises = [];
        const structureFieldState = (field, passesCondition, data = {}) => {
            var _a;
            const value = typeof (data === null || data === void 0 ? void 0 : data[field.name]) !== 'undefined' ? data[field.name] : field.defaultValue;
            const fieldState = {
                value,
                initialValue: value,
                valid: true,
                validate: field.validate,
                condition: (_a = field.admin) === null || _a === void 0 ? void 0 : _a.condition,
                passesCondition,
            };
            validationPromises.push(buildValidationPromise(fieldState, {
                ...field,
                fullData,
                user,
                siblingData: data,
                id,
                operation,
            }));
            return fieldState;
        };
        const iterateFields = (fields, data, parentPassesCondition, path = '') => fields.reduce((state, field) => {
            var _a, _b;
            let initialData = data;
            if (!fieldIsPresentationalOnly(field) && !((_a = field === null || field === void 0 ? void 0 : field.admin) === null || _a === void 0 ? void 0 : _a.disabled)) {
                if (fieldAffectsData(field) && field.defaultValue && typeof (initialData === null || initialData === void 0 ? void 0 : initialData[field.name]) === 'undefined') {
                    initialData = { [field.name]: field.defaultValue };
                }
                const passesCondition = Boolean((((_b = field === null || field === void 0 ? void 0 : field.admin) === null || _b === void 0 ? void 0 : _b.condition) ? field.admin.condition(fullData || {}, initialData || {}) : true) && parentPassesCondition);
                if (fieldAffectsData(field)) {
                    if (field.type === 'relationship' && (initialData === null || initialData === void 0 ? void 0 : initialData[field.name]) === null) {
                        initialData[field.name] = 'null';
                    }
                    if (field.type === 'array' || field.type === 'blocks') {
                        if (Array.isArray(initialData === null || initialData === void 0 ? void 0 : initialData[field.name])) {
                            const rows = initialData[field.name];
                            if (field.type === 'array') {
                                return {
                                    ...state,
                                    ...rows.reduce((rowState, row, i) => {
                                        const rowPath = `${path}${field.name}.${i}.`;
                                        return {
                                            ...rowState,
                                            [`${rowPath}id`]: {
                                                value: row.id,
                                                initialValue: row.id || new ObjectID().toHexString(),
                                                valid: true,
                                            },
                                            ...iterateFields(field.fields, row, passesCondition, rowPath),
                                        };
                                    }, {}),
                                };
                            }
                            if (field.type === 'blocks') {
                                return {
                                    ...state,
                                    ...rows.reduce((rowState, row, i) => {
                                        const block = field.blocks.find((blockType) => blockType.slug === row.blockType);
                                        const rowPath = `${path}${field.name}.${i}.`;
                                        return {
                                            ...rowState,
                                            [`${rowPath}blockType`]: {
                                                value: row.blockType,
                                                initialValue: row.blockType,
                                                valid: true,
                                            },
                                            [`${rowPath}blockName`]: {
                                                value: row.blockName,
                                                initialValue: row.blockName,
                                                valid: true,
                                            },
                                            [`${rowPath}id`]: {
                                                value: row.id,
                                                initialValue: row.id || new ObjectID().toHexString(),
                                                valid: true,
                                            },
                                            ...((block === null || block === void 0 ? void 0 : block.fields) ? iterateFields(block.fields, row, passesCondition, rowPath) : {}),
                                        };
                                    }, {}),
                                };
                            }
                        }
                        return state;
                    }
                    // Handle non-array-based nested fields (group, etc)
                    if (field.type === 'group') {
                        const subFieldData = initialData === null || initialData === void 0 ? void 0 : initialData[field.name];
                        return {
                            ...state,
                            ...iterateFields(field.fields, subFieldData, passesCondition, `${path}${field.name}.`),
                        };
                    }
                    return {
                        ...state,
                        [`${path}${field.name}`]: structureFieldState(field, passesCondition, data),
                    };
                }
                // Handle field types that do not use names (row, etc)
                if (field.type === 'row') {
                    return {
                        ...state,
                        ...iterateFields(field.fields, data, passesCondition, path),
                    };
                }
                const namedField = field;
                // Handle normal fields
                return {
                    ...state,
                    [`${path}${namedField.name}`]: structureFieldState(field, passesCondition, data),
                };
            }
            return state;
        }, {});
        const resultingState = iterateFields(fieldSchema, fullData, true);
        await Promise.all(validationPromises);
        return resultingState;
    }
    return {};
};
export default buildStateFromSchema;
